# Laravel Boardgame Plays & Statistics Platform - Cursor Rules

## Project Overview
This is a Laravel-based boardgame plays and statistics platform for groups. The project follows an API-first approach with comprehensive testing and clear, descriptive naming conventions.

## Tech Stack
- **Backend**: Laravel (PHP 8.2+)
- **Frontend**: Inertia.js + Vue 3
- **Database**: PostgreSQL
- **Cache/Sessions/Queues**: Redis
- **Search**: Meilisearch (full-text and faceted search)
- **Object Storage**: Local storage
- **Realtime**: Laravel Echo + WebSockets (Pusher or self-hosted)
- **Background Jobs**: Laravel Queue Workers with Supervisor/Horizon
- **Notifications**: Laravel Notifications (Postmark/SendGrid for email, Discord webhooks, in-app via Redis + DB)
- **API Documentation**: OpenAPI/Swagger (generate clients)
- **Monitoring**: Sentry (errors), Prometheus/Grafana (metrics), Grafana Loki (logs)

## Core Principles

### 1. Naming Conventions (CRITICAL)
- **ALWAYS use clear, descriptive, and full names** - no abbreviations unless they are industry-standard (e.g., `id`, `url`, `api`)
- **Classes**: PascalCase with descriptive names (e.g., `BoardGamePlayRecordController`, `PlayerStatisticsService`, `GameSessionRepository`)
- **Methods/Functions**: camelCase with verb-noun pattern (e.g., `calculatePlayerWinRate()`, `storeGamePlayRecord()`, `retrievePlayerStatistics()`)
- **Variables**: camelCase with descriptive names (e.g., `playerWinCount`, `gameSessionDuration`, `totalPlayRecords`)
- **Database Tables**: snake_case, plural (e.g., `board_game_plays`, `player_statistics`, `game_sessions`)
- **Database Columns**: snake_case, descriptive (e.g., `player_id`, `game_session_id`, `played_at`, `win_count`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_PLAYERS_PER_SESSION`, `DEFAULT_STATISTICS_REFRESH_INTERVAL`)
- **Routes**: kebab-case (e.g., `/api/board-game-plays`, `/api/player-statistics`)
- **Vue Components**: PascalCase (e.g., `BoardGamePlayForm.vue`, `PlayerStatisticsDashboard.vue`)
- **Vue Props/Variables**: camelCase (e.g., `playerStatistics`, `gamePlayRecords`)

### 2. Testing Requirements (MANDATORY)
- **EVERY feature, class, and significant method MUST have corresponding tests**
- **Test-Driven Development (TDD) is preferred** - write tests before implementation when possible
- **Test Coverage**: Aim for minimum 80% coverage, critical paths should be 100%
- **Test Types**:
  - **Unit Tests**: For individual classes, methods, and services (PHPUnit)
  - **Feature Tests**: For HTTP endpoints, API routes, and user interactions (Laravel HTTP Tests)
  - **Integration Tests**: For database operations, external services (S3, Meilisearch, Redis)
  - **E2E Tests**: For critical user flows (Pest or PHPUnit with Dusk)
- **Test Naming**: Descriptive test names that explain what is being tested (e.g., `test_calculates_player_win_rate_correctly_when_player_has_multiple_games()`, `test_stores_board_game_play_record_with_valid_data()`)
- **Test Organization**: Mirror application structure in `tests/` directory
- **Test Data**: Use factories and seeders for consistent test data
- **Before writing any code, ensure tests are written or updated**

### 3. Laravel Best Practices

#### Architecture
- **Use Service Classes** for business logic (not controllers)
- **Use Repository Pattern** for data access when appropriate
- **Use Form Requests** for validation (never validate in controllers)
- **Use Resource Classes** for API responses (API Resources)
- **Use DTOs (Data Transfer Objects)** for complex data structures
- **Follow SOLID principles** and DRY (Don't Repeat Yourself)
- **Use Dependency Injection** - avoid facades in business logic when possible

#### Controllers
- Keep controllers thin - delegate to services
- Use single-action controllers for complex operations when appropriate
- Return JSON responses for API endpoints
- Use Inertia responses for frontend routes

#### Models
- Use Eloquent relationships with descriptive names
- Define accessors/mutators with clear names
- Use scopes for reusable query logic
- Use casts for type conversion
- Define fillable/guarded properties explicitly

#### Database
- Use migrations for all schema changes
- Add indexes for frequently queried columns
- Use foreign key constraints
- Use database transactions for multi-step operations
- Use soft deletes when appropriate (e.g., `deleted_at`)

#### API Design
- **API-First Approach**: Design APIs before frontend implementation
- Use RESTful conventions where appropriate
- Version APIs (e.g., `/api/v1/`)
- Use OpenAPI/Swagger for documentation
- Return consistent response formats
- Use proper HTTP status codes
- Implement rate limiting
- Use API authentication (Sanctum/Passport)

### 4. Code Quality Standards

#### PHP Standards
- Follow PSR-12 coding standard
- Use strict types: `declare(strict_types=1);` at the top of all PHP files
- Use type hints for all parameters and return types
- Use nullable types (`?string`, `?int`) when values can be null
- Avoid magic numbers - use named constants
- Use early returns to reduce nesting
- Keep functions/methods small and focused (single responsibility)

#### Documentation
- Use PHPDoc blocks for all classes, methods, and complex logic
- Document complex algorithms and business rules
- Include parameter types, return types, and exceptions in PHPDoc
- Document API endpoints with OpenAPI annotations

#### Error Handling
- Use custom exceptions with descriptive names
- Log errors appropriately (use Laravel's logging)
- Return meaningful error messages to API consumers
- Use try-catch blocks for external service calls (S3, Meilisearch, etc.)

### 5. Frontend (Inertia + Vue)

#### Vue Components
- Use Composition API (Vue 3) with `<script setup>`
- Use TypeScript for type safety (if applicable)
- Keep components small and focused
- Use props validation
- Emit events with descriptive names
- Use computed properties for derived state
- Use reactive/ref appropriately

#### Inertia
- Use Inertia forms for form handling
- Use Inertia links for navigation
- Handle loading states properly
- Use Inertia's error handling

#### Styling
- Use Tailwind CSS (or specified CSS framework)
- Keep styles scoped to components when possible
- Use consistent spacing and design tokens

### 6. Database & Caching

#### PostgreSQL
- Use proper data types (avoid TEXT when VARCHAR is sufficient)
- Use JSON/JSONB columns for flexible data when appropriate
- Use database transactions for data integrity
- Use database indexes strategically
- Use database migrations for all changes

#### Redis
- Use Redis for caching frequently accessed data
- Use Redis for session storage
- Use Redis for queue management
- Cache expensive queries and computations
- Set appropriate TTLs for cached data

#### Meilisearch
- Index models that need full-text search
- Use faceted search for filtering
- Keep search indexes in sync with database
- Handle search errors gracefully

### 7. Background Jobs & Queues

#### Queue Jobs
- Use descriptive job class names (e.g., `CalculatePlayerStatisticsJob`, `SendGameSessionNotificationJob`)
- Make jobs idempotent when possible
- Handle job failures appropriately
- Use job batching for related operations
- Use Laravel Horizon for queue monitoring

#### Supervisor
- Configure Supervisor for queue workers
- Set appropriate worker counts
- Handle worker restarts gracefully

### 8. Notifications & Email

#### Laravel Notifications
- Use notification classes for all notifications
- Support multiple channels (email, Discord, in-app)
- Use notification queues for async delivery
- Provide clear, actionable notification content

#### Email
- Use Postmark or SendGrid for transactional emails
- Use email templates (Blade or Markdown)
- Include proper email headers
- Handle email failures gracefully

### 9. Monitoring & Observability

#### Error Tracking
- Use Sentry for error tracking
- Include context in error reports
- Set up alerts for critical errors

#### Metrics
- Use Prometheus for metrics collection
- Expose relevant application metrics
- Use Grafana for visualization

#### Logging
- Use Grafana Loki for log aggregation
- Log at appropriate levels (debug, info, warning, error)
- Include context in log messages
- Use structured logging

### 10. Security

#### Authentication & Authorization
- Use Laravel Sanctum or Passport for API authentication
- Implement proper authorization policies
- Use middleware for route protection
- Validate and sanitize all user input

#### Data Protection
- Use HTTPS for all communications
- Encrypt sensitive data at rest
- Use parameterized queries (Eloquent handles this)
- Protect against SQL injection, XSS, CSRF

### 11. File Structure

```
app/
  Console/
  Exceptions/
  Http/
    Controllers/
      Api/
        V1/
    Middleware/
    Requests/
    Resources/
  Models/
  Services/
  Repositories/
  DTOs/
  Jobs/
  Notifications/
  Events/
  Listeners/
  Policies/
tests/
  Unit/
  Feature/
  Integration/
resources/
  js/
    components/
    pages/
    composables/
    types/
  views/
database/
  factories/
  migrations/
  seeders/
routes/
  api.php
  web.php
```

### 12. Git & Version Control

#### Commit Messages
- Use clear, descriptive commit messages
- Reference issue numbers when applicable
- Follow conventional commits format when possible

#### Branching
- Use feature branches for new features
- Use descriptive branch names (e.g., `feature/player-statistics-calculation`, `fix/board-game-play-validation`)

### 13. Code Review Checklist

Before submitting code, ensure:
- [ ] All tests pass
- [ ] New code has corresponding tests
- [ ] Code follows naming conventions
- [ ] Code is properly documented
- [ ] No hardcoded values (use config/env)
- [ ] Error handling is implemented
- [ ] Security considerations are addressed
- [ ] Performance implications are considered
- [ ] Database migrations are included if needed
- [ ] API documentation is updated (OpenAPI)

### 14. When Writing Code

**ALWAYS:**
1. Write tests first (TDD) or alongside code
2. Use full, descriptive names for everything
3. Add PHPDoc comments for complex logic
4. Handle errors appropriately
5. Follow Laravel conventions
6. Consider performance implications
6. Think about security
7. Update API documentation if adding/changing endpoints

**NEVER:**
1. Skip writing tests
2. Use abbreviations or unclear names
3. Put business logic in controllers
4. Hardcode configuration values
5. Ignore error handling
6. Commit code without tests

### 15. Specific to Boardgame Platform

#### Domain Models
- Use clear domain terminology (e.g., `BoardGame`, `GamePlay`, `Player`, `GameSession`, `PlayerStatistics`)
- Model relationships clearly (e.g., a `GamePlay` belongs to a `BoardGame` and a `GameSession`, a `GameSession` has many `GamePlays`)

#### Statistics
- Calculate statistics efficiently (consider caching)
- Use database aggregations when possible
- Store computed statistics when appropriate
- Update statistics asynchronously via jobs

#### Real-time Features
- Use Laravel Echo for real-time updates
- Broadcast events for game sessions, statistics updates
- Handle WebSocket connection failures gracefully

#### BoardGameGeek (BGG) API Integration (CRITICAL)

**Core Principle: SYNC, NOT DEPENDENCY**
- **NEVER make real-time API calls to BoardGameGeek.com during user requests**
- **ALWAYS store BGG data locally in the database**
- **ALWAYS use background jobs for syncing data from BGG**
- The application must function completely independently of BGG API availability
- BGG API calls are for data synchronization only, not for serving user requests

**Architecture Requirements:**

1. **Data Storage**
   - Store all BGG data locally in PostgreSQL (e.g., `board_games` table with `bgg_id`)
   - Store raw XML responses or parsed data in JSON/JSONB columns when needed
   - Track sync metadata: `bgg_synced_at`, `bgg_sync_status`, `bgg_sync_error_message`
   - Use `bgg_id` as the unique identifier linking local records to BGG

2. **Service Layer**
   - Create a dedicated service class: `BoardGameGeekSyncService` or `BoardGameGeekApiClient`
   - Service should handle XML parsing, rate limiting, error handling
   - Service methods should be idempotent and handle partial failures gracefully
   - Use DTOs for BGG API responses (e.g., `BoardGameGeekGameDto`)

3. **Background Jobs (MANDATORY)**
   - **ALL BGG API calls MUST be in background jobs**
   - Job naming: `SyncBoardGameFromBoardGameGeekJob`, `SyncBoardGameCollectionFromBoardGameGeekJob`
   - Jobs should be idempotent (safe to retry)
   - Use job batching for bulk sync operations
   - Implement exponential backoff for rate limit errors
   - Queue jobs with appropriate delays to respect rate limits

4. **Rate Limiting & Respect**
   - BGG API has strict rate limits (typically 1 request per second)
   - Implement rate limiting in the service layer using Redis or Laravel's rate limiter
   - Use job delays to space out requests (e.g., `dispatch()->delay(now()->addSeconds(2))`)
   - Track rate limit headers from BGG responses and adjust accordingly
   - Never make synchronous API calls that could block or violate rate limits

5. **Sync Strategies**
   - **Initial Sync**: When a user adds a BGG ID, queue a job to fetch and store data
   - **Periodic Sync**: Use scheduled commands (Laravel Scheduler) to sync stale data
   - **On-Demand Sync**: Allow users to trigger sync via API endpoint that queues a job
   - **Bulk Sync**: Support syncing collections or multiple games via batched jobs
   - Track sync frequency and avoid unnecessary API calls

6. **Error Handling**
   - Handle BGG API downtime gracefully - application continues to work with cached data
   - Log all BGG API errors with context (BGG ID, endpoint, response)
   - Store sync errors in database for user visibility
   - Implement retry logic with exponential backoff for transient failures
   - Never throw exceptions that break user workflows - always fall back to local data

7. **User Experience**
   - When displaying board game data, ALWAYS use local database data
   - Show sync status indicators (e.g., "Last synced: 2 hours ago", "Sync in progress")
   - Allow users to manually trigger sync (queues a job, doesn't wait)
   - Show helpful messages if sync fails (e.g., "BGG API temporarily unavailable, using cached data")
   - Never show loading states waiting for BGG API responses

8. **Testing Requirements**
   - **MOCK all BGG API calls in tests** - never make real API calls during testing
   - Use HTTP mocking (e.g., Laravel's `Http::fake()`) for BGG API responses
   - Test sync jobs with mocked API responses
   - Test error scenarios (API down, rate limits, invalid responses)
   - Test that application works when BGG API is unavailable
   - Integration tests should verify sync job behavior without real API calls

9. **Configuration**
   - Store BGG API base URL in config file (e.g., `config/boardgamegeek.php`)
   - Make rate limit settings configurable (requests per second, delay between requests)
   - Allow disabling BGG sync via feature flag for maintenance
   - Store sync intervals and retry settings in config

10. **Monitoring & Observability**
    - Log all BGG API requests with timing, status codes, and response sizes
    - Track sync job success/failure rates
    - Monitor rate limit violations and adjust delays accordingly
    - Alert on repeated sync failures or BGG API downtime
    - Track sync latency and optimize job scheduling

11. **Code Examples Pattern**
    ```php
    // ✅ CORRECT: Queue a job for sync
    public function store(Request $request): JsonResponse
    {
        $boardGame = BoardGame::create($request->validated());
        
        if ($request->has('bgg_id')) {
            SyncBoardGameFromBoardGameGeekJob::dispatch($boardGame->id)
                ->delay(now()->addSeconds(2)); // Respect rate limits
        }
        
        return new BoardGameResource($boardGame);
    }
    
    // ❌ WRONG: Making real-time API call
    public function store(Request $request): JsonResponse
    {
        $bggData = $this->boardGameGeekApiClient->fetchGame($request->bgg_id); // NEVER DO THIS
        // ...
    }
    ```

12. **File Structure for BGG Integration**
    ```
    app/
      Services/
        BoardGameGeekSyncService.php
        BoardGameGeekApiClient.php
      Jobs/
        SyncBoardGameFromBoardGameGeekJob.php
        SyncBoardGameCollectionFromBoardGameGeekJob.php
      DTOs/
        BoardGameGeekGameDto.php
        BoardGameGeekCollectionDto.php
      Console/
        Commands/
          SyncStaleBoardGamesFromBoardGameGeekCommand.php
    config/
      boardgamegeek.php
    ```

**Summary of BGG Integration Rules:**
- ✅ Store all BGG data locally in database
- ✅ Use background jobs for ALL BGG API calls
- ✅ Respect rate limits with delays and queuing
- ✅ Handle errors gracefully - app works without BGG
- ✅ Mock BGG API in all tests
- ❌ NEVER make synchronous BGG API calls in controllers/services
- ❌ NEVER depend on BGG API for serving user requests
- ❌ NEVER make real API calls in tests

## Summary

**Priority 1: Clear, Full Names** - Every identifier must be self-documenting
**Priority 2: Comprehensive Testing** - Every feature must have tests
**Priority 3: Code Quality** - Follow Laravel best practices and PSR standards
**Priority 4: API-First** - Design APIs before frontend
**Priority 5: Observability** - Monitor, log, and track errors

Remember: Code is read more often than it's written. Write code that your future self (and teammates) will understand immediately.

This ruleset covers:
- Clear, descriptive naming conventions
- Mandatory testing requirements
- Laravel best practices aligned with your stack
- API-first approach with OpenAPI
- Integration guidance for your services (Redis, Meilisearch, S3, WebSockets)
- BoardGameGeek API integration (sync pattern, not dependency)
- Monitoring and observability practices
- Security considerations
